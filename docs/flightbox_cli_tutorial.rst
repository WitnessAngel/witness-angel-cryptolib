Flightbox CLI Tutorial
===================================

CLI overview
-----------------

The flightbox command-line utility provides subcommands for end-to-end workflows around cryptainers.

.. command-output:: flightbox -h

Note the keystore-pool and cryptainer-storage options: the first one is used to store local and imported keystores, and the second one is used to store encrypted containers.

.. hint::

    The positioning of CLI options is rather strict: they must be added directly after the command they are related too, and before the following subcommand. So for example `--gateway-url` must be provided after `flightbox`, but before subcommands like `cryptainer`, `encrypt` etc.


Playing with default encryption
--------------------------------

Imagine that we won't to encrypt a readme file. The corresponding command could be as simple as:

.. command-output:: flightbox encrypt readme.rst

But as the output mentions, this is not a satisfying encryption.
Let's check the structure of the resulting "cryptainer", which has been saved into default cryptainer storage.

.. command-output:: flightbox cryptainer list

.. hint::

    For performance reasons, the cryptainer is, by default, "offloaded". This means it is separated in two files: the metadata in "readme.rst.crypt", and the (possibly huge) encrypted data in "readme.rst.crypt.payload".


.. command-output:: flightbox cryptainer summarize readme.rst.crypt

As we see, the cryptainer uses several types of encryption, but only relies on autogenerated local-device keys, which are not protected by a passphrase.

.. hint::

    If you open readme.rst.crypt with a text editor, you'll notice that it's just a JSON file, but in Pymongo's Extended Json format: it uses specific fields like $binary or $date to add better types to the serialized data.


Creating an authenticator trustee
----------------------------------

To encrypt data in a more secure fashion, we'll need some key guardians, called `trustees` in Flightbox.

The simplest form of trustee is an authenticator, a digital identity for a single person. Currently, it is backed by a keystore folder containing some metadata and a bunch of keypairs - all protected by the same "passphrase" (a very long password).

The standard way of generating this identity would be to use a standalone program like the mobile application Witness Angel Authenticator (for Android and iOS), and then to publish the public part of this identity to a web registry.

But we can also create authenticators via the CLI:

.. command-output:: flightbox authenticator create ~/mysphinxdocauthenticator --owner "John Doe" --passphrase-hint "Some hint"

For the needs of this doc generation, we had to provide the passphrase as an environment variable, but normally the program will just prompt the user for it.

We can then review the just-created authenticator:

.. command-output:: flightbox authenticator view ~/mysphinxdocauthenticator

And we can check, later, that we still remember the right passphrase:

.. command-output:: flightbox authenticator validate ~/mysphinxdocauthenticator

We can later delete the authenticator with ``flightbox authenticator delete ~/mysphinxdocauthenticator``, which is the same as manually deleting the folder.


Importing foreign keystores
----------------------------------

Authenticators are supposed to be remote identities, well protected by their owner.
To use them in our encryption system, we need to import their public keys, which are like "padlocks".
That's what we call "foreign keystores" - partial local copies of remote identities.

Let's begin by importing the authenticator we just created.

.. command-output:: flightbox foreign-keystore import --from-path ~/mysphinxdocauthenticator

Let's also import an identity from a web registry, using its UUID that the owner gave us directly.

.. command-output:: flightbox --gateway-url https://api.witnessangel.com/gateway/jsonrpc/ foreign-keystore import --from-gateway 0f0c0988-80c1-9362-11c1-b06909a3a53c

If we have setup authenticators in default locations of connected USB keys, we can automatically import them:

.. command-output:: flightbox foreign-keystore import --from-usb --include-private-keys

.. warning::

    The `--include-private-keys` option requests that the private part of the identity be imported too, if present (which is not the case e.g. for web gateway identities). This is only useful if one intends to decrypt data locally, by entering passphrases during decryption. But much more secure workflows are now available, for example by using the mobile application Authenticator.

We can then review the imported keystores, which will be usable for encryption:

.. command-output:: flightbox foreign-keystore list

And we can check the keypairs present in a specific keystore, this way:

.. command-output:: flightbox foreign-keystore view 0f0c0988-80c1-9362-11c1-b06909a3a53c

We can later delete the foreign keystore with ``flightbox foreign-keystore delete 0f0c0988-80c1-9362-11c1-b06909a3a53c``, which is the same as manually deleting the folder deep inside the keystore pool.



Generating simple cryptoconfs
--------------------------------

Now that we have locally registered some trustees, it's time to specify how they should protect our data, how they should become our "key guardians". This happens with a cryptoconf, a JSON cryptainer template recursively describing the different layers of encryption to be used on data and on keys, as well as the signatures to apply.

Cryptoconf can be very complex; but for some low-depth, signatureless cases, we can use the CLI to generate a cryptoconf for us.

For example, imagine we want to encrypt the data using the AES-CBC cipher, and then protect the (random) secret key of this cipher using a keypair of the trustee imported from the web gateway.

.. command-output:: flightbox cryptoconf generate-simple add-payload-cipher-layer --sym-cipher-algo AES_CBC add-key-cipher-layer --asym-cipher-algo RSA_OAEP --trustee-type authenticator --keystore-uid 0f0c0988-80c1-9362-11c1-b06909a3a53c --keychain-uid 0f0c0989-1111-a226-c471-99cbb2d203c3

The UUIDs that we selected are well there, even if unrecognizable in the $binary/base64 format of the JSON.

We can go farther, and decide that we want two layers of data encryption:

- one protected by an autogenerated local key
- the other protected by a shared secret between two authenticators, any of these two being sufficient to decrypt the data.

Here is how such a configuration could be generated::

    $ flightbox cryptoconf generate-simple
        add-payload-cipher-layer --sym-cipher-algo AES_CBC
            add-key-cipher-layer --asym-cipher-algo RSA_OAEP --trustee-type local_keyfactory
        add-payload-cipher-layer --sym-cipher-algo CHACHA20_POLY1305
            add-key-shared-secret --threshold 1
                add-key-shard --asym-cipher-algo RSA_OAEP --trustee-type authenticator --keystore-uid 0f0c0988-80c1-9362-11c1-b06909a3a53c --keychain-uid 0f0c0989-1111-a226-c471-99cbb2d203c3
                add-key-shard --asym-cipher-algo RSA_OAEP --trustee-type authenticator --keystore-uid 7a25db2c-4c4e-42bb-a064-8da2007a4fd7 --keychain-uid 8c57e283-308a-4c78-86f9-ee6176757a6f
        > shared-secret-cryptoconf.json``

And here is the resulting cryptoconf structure:

::

    $ flightbox cryptoconf summarize sophisticated-cryptoconf.json

    Data encryption layer 1: AES_CBC
      Key encryption layers:
        RSA_OAEP via trustee 'local device'
      Signatures: None
    Data encryption layer 2: CHACHA20_POLY1305
      Key encryption layers:
        Shared secret with threshold 1:
          Shard 1 encryption layers:
            RSA_OAEP via trustee 'authenticator 0f0c0988-80c1-9362-11c1-b06909a3a53c'
          Shard 2 encryption layers:
            RSA_OAEP via trustee 'authenticator 7a25db2c-4c4e-42bb-a064-8da2007a4fd7'
      Signatures: None


If we want a logical AND instead of a logical OR between the two authenticator-based trustees, either we increase the `threshold` to 2, or we apply the trustee protections one after the other, like this::

    $ flightbox cryptoconf generate-simple add-payload-cipher-layer --sym-cipher-algo AES_CBC
        add-key-cipher-layer --asym-cipher-algo RSA_OAEP --trustee-type authenticator --keystore-uid 0f0c0988-80c1-9362-11c1-b06909a3a53c --keychain-uid 0f0c0989-1111-a226-c471-99cbb2d203c3 --sym-cipher-algo AES_EAX
        add-key-cipher-layer --asym-cipher-algo RSA_OAEP --trustee-type authenticator --keystore-uid 7a25db2c-4c4e-42bb-a064-8da2007a4fd7 --keychain-uid 8c57e283-308a-4c78-86f9-ee6176757a6f
        > multikeylayer-cryptoconf.json

Which gives this structure:

::

    $ flightbox cryptoconf summarize multikeylayer-cryptoconf.json

    Data encryption layer 1: AES_CBC
      Key encryption layers:
        AES_EAX with subkey encryption layers:
          RSA_OAEP via trustee 'authenticator 0f0c0988-80c1-9362-11c1-b06909a3a53c'
        RSA_OAEP via trustee 'authenticator 7a25db2c-4c4e-42bb-a064-8da2007a4fd7'
      Signatures: None

Thus, the randomly generated AES-CBC is secured by the first trustee, and then the result of this encryption is fed to the second trustee, which secures it too.

.. hint::

    Note that we used an hybrid encryption (AES-EAX/RSA-OAEP) for the first layer of key encryption; this is not mandatory, but it avoid stacking trustees directly one over the other in these "Key encryption layers".

    When trustees are directly stacked, decryption is complicated because we must decrypt the Key through the upper layer, before being able to query the next trustee for authorization, using the now partially-decrypted Key.

    When trustees are separated "leaves" of the cryptoconf/cryptainer tree, on the contrary, they can all be queried in parallel for authorizations, each one being fed its corresponding encrypted "Key" (here, respectively the encrypted AES-CBC and AES-EAX keys).

Note that a ``flightbox cryptoconf validate <file>`` command is available, to check JSON cryptoconfs that you have generated by other means.
