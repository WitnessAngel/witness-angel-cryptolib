import copy
import random
from unittest import mock

import pytest
from Crypto.Random import get_random_bytes

from wacryptolib.cipher import _encrypt_via_rsa_oaep
from wacryptolib.exceptions import (
    KeyDoesNotExist,
    SignatureVerificationError,
    DecryptionError,
    ValidationError,
    AuthorizationError,
)
from wacryptolib.keygen import load_asymmetric_key_from_pem_bytestring
from wacryptolib.keystore import (
    InMemoryKeystore,
    generate_free_keypair_for_least_provisioned_key_algo,
    generate_keypair_for_storage,
)
from wacryptolib.signature import verify_message_signature
from wacryptolib.trustee import TrusteeApi, ReadonlyTrusteeApi
from wacryptolib.utilities import generate_uuid0


def test_trustee_api_workflow():

    keystore = InMemoryKeystore()
    trustee_api = TrusteeApi(keystore=keystore)

    keychain_uid = generate_uuid0()
    keychain_uid_other = generate_uuid0()
    keychain_uid_unexisting = generate_uuid0()
    secret = get_random_bytes(127)
    secret_too_big = get_random_bytes(140)

    for _ in range(2):
        generate_free_keypair_for_least_provisioned_key_algo(
            keystore=keystore, max_free_keys_per_algo=10, key_algos=["RSA_OAEP", "DSA_DSS"]
        )
    assert keystore.get_free_keypairs_count("DSA_DSS") == 1
    assert keystore.get_free_keypairs_count("ECC_DSS") == 0
    assert keystore.get_free_keypairs_count("RSA_OAEP") == 1
    assert keystore.get_free_keypairs_count("RSA_PSS") == 0  # Different from other RSA keys

    # Keypair is well auto-created by get_public_key(), by default
    public_key_rsa_oaep_pem = trustee_api.fetch_public_key(keychain_uid=keychain_uid, key_algo="RSA_OAEP")

    with pytest.raises(KeyDoesNotExist, match="not found"):  # Key NOT autogenerated
        trustee_api.fetch_public_key(keychain_uid=generate_uuid0(), key_algo="RSA_OAEP", must_exist=True)

    _public_key_rsa_oaep_pem2 = trustee_api.fetch_public_key(keychain_uid=keychain_uid, key_algo="RSA_OAEP")
    assert _public_key_rsa_oaep_pem2 == public_key_rsa_oaep_pem  # Same KEYS!

    _public_key_rsa_pss_pem = trustee_api.fetch_public_key(keychain_uid=keychain_uid, key_algo="RSA_PSS")
    assert _public_key_rsa_pss_pem != public_key_rsa_oaep_pem  # Different KEYS!

    public_key_rsa_oaep = load_asymmetric_key_from_pem_bytestring(key_pem=public_key_rsa_oaep_pem, key_algo="RSA_OAEP")

    assert keystore.get_free_keypairs_count("DSA_DSS") == 1
    assert keystore.get_free_keypairs_count("ECC_DSS") == 0
    assert keystore.get_free_keypairs_count("RSA_OAEP") == 0  # Taken
    assert keystore.get_free_keypairs_count("RSA_PSS") == 0

    signature = trustee_api.get_message_signature(keychain_uid=keychain_uid, message=secret, signature_algo="DSA_DSS")

    with pytest.raises(ValidationError, match="too big"):
        trustee_api.get_message_signature(keychain_uid=keychain_uid, message=secret_too_big, signature_algo="DSA_DSS")

    assert keystore.get_free_keypairs_count("DSA_DSS") == 0  # Taken
    assert keystore.get_free_keypairs_count("ECC_DSS") == 0
    assert keystore.get_free_keypairs_count("RSA_OAEP") == 0
    assert keystore.get_free_keypairs_count("RSA_PSS") == 0

    public_key_dsa_pem = trustee_api.fetch_public_key(keychain_uid=keychain_uid, key_algo="DSA_DSS")
    public_key_dsa = load_asymmetric_key_from_pem_bytestring(key_pem=public_key_dsa_pem, key_algo="DSA_DSS")

    verify_message_signature(message=secret, signature=signature, key=public_key_dsa, signature_algo="DSA_DSS")
    signature["signature_value"] += b"xyz"
    with pytest.raises(SignatureVerificationError, match="Failed.*verification"):
        verify_message_signature(message=secret, signature=signature, key=public_key_dsa, signature_algo="DSA_DSS")

    # Keypair is well auto-created by get_message_signature(), even when no more free keys
    signature = trustee_api.get_message_signature(
        keychain_uid=keychain_uid_other, message=secret, signature_algo="RSA_PSS"
    )
    assert signature

    # Keypair well autocreated by get_public_key(), even when no more free keys
    public_key_pem = trustee_api.fetch_public_key(keychain_uid=keychain_uid_other, key_algo="DSA_DSS")
    assert public_key_pem

    cipherdict = _encrypt_via_rsa_oaep(plaintext=secret, key_dict=dict(key=public_key_rsa_oaep))

    # Works even without decryption authorization request, by default:
    decrypted = trustee_api.decrypt_with_private_key(
        keychain_uid=keychain_uid, cipher_algo="RSA_OAEP", cipherdict=cipherdict
    )
    assert decrypted == secret

    # NO auto-creation of keypair in decrypt_with_private_key()
    with pytest.raises(KeyDoesNotExist, match="not found"):
        trustee_api.decrypt_with_private_key(
            keychain_uid=keychain_uid_unexisting, cipher_algo="RSA_OAEP", cipherdict=cipherdict
        )

    wrong_cipherdict = copy.deepcopy(cipherdict)
    wrong_cipherdict["digest_list"].append(b"aaabbbccc")
    with pytest.raises(DecryptionError, match="Ciphertext with incorrect length"):
        trustee_api.decrypt_with_private_key(
            keychain_uid=keychain_uid, cipher_algo="RSA_OAEP", cipherdict=wrong_cipherdict
        )

    with pytest.raises(ValueError, match="empty"):
        trustee_api.request_decryption_authorization(keypair_identifiers=[], request_message="I need this decryption!")

    # Authorization always granted for now, in dummy implementation
    result = trustee_api.request_decryption_authorization(
        keypair_identifiers=[dict(keychain_uid=keychain_uid, key_algo="RSA_OAEP")],
        request_message="I need this decryption!",
        cryptainer_metadata=random.choice((None, {"hello": "bye"})),
    )
    assert "accepted" in result["response_message"]
    assert not result["has_errors"]
    assert result["keypair_statuses"]["accepted"]

    with mock.patch("wacryptolib.trustee.TrusteeApi._check_keypair_authorization", side_effect=AuthorizationError):
        result = trustee_api.request_decryption_authorization(
            keypair_identifiers=[dict(keychain_uid=keychain_uid, key_algo="RSA_OAEP")],
            request_message="I need this decryption too!",
        )
        assert "denied" in result["response_message"]
        assert result["has_errors"]
        assert result["keypair_statuses"]["authorization_missing"]

    # TEST PASSPHRASE PROTECTIONS

    keychain_uid_passphrased = generate_uuid0()
    good_passphrase = "good_passphrase"

    keypair_cipher_passphrased = generate_keypair_for_storage(
        key_algo="RSA_OAEP", keystore=keystore, keychain_uid=keychain_uid_passphrased, passphrase=good_passphrase
    )

    result = trustee_api.request_decryption_authorization(
        keypair_identifiers=[dict(keychain_uid=keychain_uid_passphrased, key_algo="RSA_OAEP")],
        request_message="I need this decryption too!",
    )
    assert "denied" in result["response_message"]
    assert result["has_errors"]
    assert result["keypair_statuses"]["missing_passphrase"]

    result = trustee_api.request_decryption_authorization(
        keypair_identifiers=[dict(keychain_uid=keychain_uid_passphrased, key_algo="RSA_OAEP")],
        request_message="I need this decryption too!",
        passphrases=["aaa"],
    )
    assert "denied" in result["response_message"]
    assert result["has_errors"]
    assert result["keypair_statuses"]["missing_passphrase"]

    result = trustee_api.request_decryption_authorization(
        keypair_identifiers=[dict(keychain_uid=keychain_uid_passphrased, key_algo="RSA_OAEP")],
        request_message="I need this decryption too!",
        passphrases=["dsd", good_passphrase],
        cryptainer_metadata=random.choice((None, {"hello": "bye"})),
    )
    assert "accepted" in result["response_message"]
    assert not result["has_errors"]
    assert result["keypair_statuses"]["accepted"]

    public_key_rsa_oaep2 = load_asymmetric_key_from_pem_bytestring(
        key_pem=keypair_cipher_passphrased["public_key"], key_algo="RSA_OAEP"
    )
    cipherdict = _encrypt_via_rsa_oaep(plaintext=secret, key_dict=dict(key=public_key_rsa_oaep2))

    with pytest.raises(DecryptionError, match="not decrypt"):
        trustee_api.decrypt_with_private_key(
            keychain_uid=keychain_uid_passphrased, cipher_algo="RSA_OAEP", cipherdict=cipherdict
        )

    with pytest.raises(DecryptionError, match="not decrypt"):
        trustee_api.decrypt_with_private_key(
            keychain_uid=keychain_uid_passphrased,
            cipher_algo="RSA_OAEP",
            cipherdict=cipherdict,
            passphrases=["something"],
            cryptainer_metadata=random.choice((None, {"hello": "bye"})),
        )

    decrypted = trustee_api.decrypt_with_private_key(
        keychain_uid=keychain_uid_passphrased,
        cipher_algo="RSA_OAEP",
        cipherdict=cipherdict,
        passphrases=[good_passphrase],
        cryptainer_metadata=random.choice((None, {"hello": "bye"})),
    )
    assert decrypted == secret

    assert keystore.get_free_keypairs_count("DSA_DSS") == 0
    assert keystore.get_free_keypairs_count("ECC_DSS") == 0
    assert keystore.get_free_keypairs_count("RSA_OAEP") == 0
    assert keystore.get_free_keypairs_count("RSA_PSS") == 0


def test_readonly_trustee_api_behaviour():

    keystore = InMemoryKeystore()
    trustee_api = ReadonlyTrusteeApi(keystore=keystore)

    keychain_uid = generate_uuid0()
    key_algo_cipher = "RSA_OAEP"
    key_algo_signature = "RSA_PSS"
    secret = get_random_bytes(127)

    for must_exist in (True, False):
        with pytest.raises(KeyDoesNotExist, match="not found"):
            trustee_api.fetch_public_key(keychain_uid=keychain_uid, key_algo=key_algo_signature, must_exist=must_exist)

    with pytest.raises(KeyDoesNotExist, match="not found"):
        trustee_api.get_message_signature(keychain_uid=keychain_uid, message=secret, signature_algo="RSA_PSS")

    # Always accepted for now, dummy implementation
    result = trustee_api.request_decryption_authorization(
        keypair_identifiers=[dict(keychain_uid=keychain_uid, key_algo=key_algo_cipher)],
        request_message="I need this decryption!",
    )
    assert "denied" in result["response_message"]
    assert result["has_errors"]
    assert result["keypair_statuses"]["missing_private_key"]

    # Still no auto-creation of keypair in decrypt_with_private_key()
    with pytest.raises(KeyDoesNotExist, match="not found"):
        trustee_api.decrypt_with_private_key(keychain_uid=keychain_uid, cipher_algo=key_algo_cipher, cipherdict={})

    # Now we generate wanted keys #

    keypair_cipher = generate_keypair_for_storage(
        key_algo=key_algo_cipher, keystore=keystore, keychain_uid=keychain_uid
    )

    keypair_signature = generate_keypair_for_storage(
        key_algo=key_algo_signature, keystore=keystore, keychain_uid=keychain_uid
    )

    public_key2 = trustee_api.fetch_public_key(
        keychain_uid=keychain_uid, key_algo=key_algo_signature, must_exist=must_exist
    )
    assert public_key2 == keypair_signature["public_key"]

    signature = trustee_api.get_message_signature(keychain_uid=keychain_uid, message=secret, signature_algo="RSA_PSS")
    assert signature and isinstance(signature, dict)

    private_key_cipher = load_asymmetric_key_from_pem_bytestring(
        key_pem=keypair_cipher["private_key"], key_algo=key_algo_cipher
    )
    cipherdict = _encrypt_via_rsa_oaep(plaintext=secret, key_dict=dict(key=private_key_cipher))
    decrypted = trustee_api.decrypt_with_private_key(
        keychain_uid=keychain_uid, cipher_algo=key_algo_cipher, cipherdict=cipherdict
    )
    assert decrypted == secret
